{"display_date": "2007/08/19 13:02:00 -0700", "views_count": 357, "short_url": "http://post.ly/AKl1g", "site_id": 1292332, "site": {"subhead": null, "full_hostname": "pita.posterous.com", "name": "Pythonic Introduction to Algorithms", "profile_image_75": "http://files.posterous.com/user_profile_pics/30986/che_baarissa_ilman_paitaa.png", "hostname": "pita", "is_group": false, "time_zone": "Pacific Time (US & Canada)", "current_user_notification_frequency": "", "profile_image_35": "http://files.posterous.com/user_profile_pics/30986/che_baarissa_ilman_paitaa_thumb.png", "comment_permission": 2, "id": 1292332, "sharing_enabled": false, "posts_count": 0, "header_image": null, "is_private": false, "current_user_role": ""}, "likes": [], "allowed": true, "body_full": "<p>Hello!</p>\r\n<p>I am currently at page 77. The discussion is more theoretical (orders of growth, recurrences &amp;c.) and thus there is less stuff to re-implement. Of course, the tools given in the initial pages are among the most important ones in the book. Just not very bloggable. Go on, read'em! Don't just wait here!</p>\r\n<p>However, to keep my fingers warm, I'll do an iterator version of <code>merge</code> (of <code>merge-sort</code> -fame). It takes two sorted iterators and returns one that has the input merged together.</p>\r\n<p>This version, called <code>merged</code> is actually slightly more difficult than doing it with simple lists. You can always \u201cpeek\u201d at the start of the list or check if there are any elements left. Not so with iterators. To reduce the pain I'll create a simple wrapper class for the iterator.</p>\r\n<div class=\"CodeRay\">\n  <div class=\"code\"><pre><code>\nclass Wrapper(object):\n      &quot;&quot;&quot;A wrapper for iterable objects. Allows peeking and testing for emptiness.\n      &gt;&gt;&gt; g =Wrapper(range(10))\n      &gt;&gt;&gt; g.has_items\n      True\n      &gt;&gt;&gt; tuple(g)\n      (0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n      &gt;&gt;&gt; g.has_items\n      False\n      &gt;&gt;&gt; e =Wrapper([])\n      &gt;&gt;&gt; e.has_items\n      False\n     &quot;&quot;&quot;\n      def __init__(self, it):\n          self.it = iter(it)\n          self.has_items = True\n          self._setvalue()\n      def _setvalue(self):\n          try:\n              self.value = self.it.next()\n          except StopIteration:\n              self.has_items = False       # To simplify the for-loop\n      def __nonzero__(self):\n          return self.has_items\n      def peek(self):\n          return self.value\n      def __iter__(self):\n          return self\n      def next(self):\n          if not self.has_items:\n              raise StopIteration\n          old_val = self.value\n          self._setvalue()\n          return old_val \n</code></pre></div>\n</div>\n\r\n<p>Slightly verbose but does the trick. I originally misspelled <code>__nonzero__</code>, which created an interesting bug. The <code>StopIteration</code> exception was not caught and the entire iterator stopped cold after either of the input streams was finished. Remember count those underscores...</p>\r\n<p>Note that there are several ways to construct a wrapper that supports some of the basic operations needed for this task. I feel that this is the cleanest approach. (Please prove me wrong!)</p>\r\n<div class=\"CodeRay\">\n  <div class=\"code\"><pre><code>\ndef merged(i1, i2):\n     &quot;&quot;&quot;merge(sorted iterable1, sorted iterable2) -&gt; new sorted iterable\n      &gt;&gt;&gt; list(merged((1, 5, 9), (2, 4, 10))))\n     [1, 2, 4, 5, 9, 10]\n      &gt;&gt;&gt; &quot;&quot;.join(merged('abbg', 'gnoux'))\n     'abbggnoux'\n      &quot;&quot;&quot;\n     i1 = Wrapper(i1)\n     i2 = Wrapper(i2)\n     while i1 and i2:\n         if i1.peek() &lt; i2.peek():\n             yield i1.next()\n        else:\n            yield i2.next()\n    # At least on of these loops is a NOP\n    for x in i1:\n        yield x\n    for x in i2:\n        yield x\n</code></pre></div>\n</div>\n\r\n<p>It is possible to extend <code>merged</code> to merge several iterators at once. Left as an exercise.</p>\r\n<p>For finite <em>unsorted</em> iterators you can use a combination of <code>itertools.chain</code> and <code>sorted</code>.</p>\r\n<p>\u00a0</p>", "post_image_500": null, "id": 17759458, "twitter_account": "", "title": "Merging iterators", "media": {"images": [], "audio_files": [], "videos": []}, "comments": [], "body_cleaned": "<p>Hello!</p>\n<p>I am currently at page 77. The discussion is more theoretical (orders of growth, recurrences &amp;c.) and thus there is less stuff to re-implement. Of course, the tools given in the initial pages are among the most important ones in the book. Just not very bloggable. Go on, read'em! Don't just wait here!</p>\n<p>However, to keep my fingers warm, I'll do an iterator version of <code>merge</code> (of <code>merge-sort</code> -fame). It takes two sorted iterators and returns one that has the input merged together.</p>\n<p>This version, called <code>merged</code> is actually slightly more difficult than doing it with simple lists. You can always \u201cpeek\u201d at the start of the list or check if there are any elements left. Not so with iterators. To reduce the pain I'll create a simple wrapper class for the iterator.</p>\n<div class=\"CodeRay\">\n  <div class=\"code\"><pre>[code lang='python']\nclass Wrapper(object):\n      \"\"\"A wrapper for iterable objects. Allows peeking and testing for emptiness.\n      &gt;&gt;&gt; g =Wrapper(range(10))\n      &gt;&gt;&gt; g.has_items\n      True\n      &gt;&gt;&gt; tuple(g)\n      (0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n      &gt;&gt;&gt; g.has_items\n      False\n      &gt;&gt;&gt; e =Wrapper([])\n      &gt;&gt;&gt; e.has_items\n      False\n     \"\"\"\n      def __init__(self, it):\n          self.it = iter(it)\n          self.has_items = True\n          self._setvalue()\n      def _setvalue(self):\n          try:\n              self.value = self.it.next()\n          except StopIteration:\n              self.has_items = False       # To simplify the for-loop\n      def __nonzero__(self):\n          return self.has_items\n      def peek(self):\n          return self.value\n      def __iter__(self):\n          return self\n      def next(self):\n          if not self.has_items:\n              raise StopIteration\n          old_val = self.value\n          self._setvalue()\n          return old_val \n[/code]</pre></div>\n</div></p><p><p>Slightly verbose but does the trick. I originally misspelled <code>__nonzero__</code>, which created an interesting bug. The <code>StopIteration</code> exception was not caught and the entire iterator stopped cold after either of the input streams was finished. Remember count those underscores...</p>\n<p>Note that there are several ways to construct a wrapper that supports some of the basic operations needed for this task. I feel that this is the cleanest approach. (Please prove me wrong!)</p>\n<div class=\"CodeRay\">\n  <div class=\"code\"><pre>[code lang='python']\ndef merged(i1, i2):\n     \"\"\"merge(sorted iterable1, sorted iterable2) -&gt; new sorted iterable\n      &gt;&gt;&gt; list(merged((1, 5, 9), (2, 4, 10))))\n     [1, 2, 4, 5, 9, 10]\n      &gt;&gt;&gt; \"\".join(merged('abbg', 'gnoux'))\n     'abbggnoux'\n      \"\"\"\n     i1 = Wrapper(i1)\n     i2 = Wrapper(i2)\n     while i1 and i2:\n         if i1.peek() </pre></div>\n</div></p><p><p>It is possible to extend <code>merged</code> to merge several iterators at once. Left as an exercise.</p>\n<p>For finite <em>unsorted</em> iterators you can use a combination of <code>itertools.chain</code> and <code>sorted</code>.</p>\n<p>\u00a0</p>", "draft": false, "full_url": "http://pita.posterous.com/merging-iterators", "scheduled": false, "tags": [], "body_html": "<p>Hello!</p>\r\n<p>I am currently at page 77. The discussion is more theoretical (orders of growth, recurrences &amp;c.) and thus there is less stuff to re-implement. Of course, the tools given in the initial pages are among the most important ones in the book. Just not very bloggable. Go on, read'em! Don't just wait here!</p>\r\n<p>However, to keep my fingers warm, I'll do an iterator version of <code>merge</code> (of <code>merge-sort</code> -fame). It takes two sorted iterators and returns one that has the input merged together.</p>\r\n<p>This version, called <code>merged</code> is actually slightly more difficult than doing it with simple lists. You can always \u201cpeek\u201d at the start of the list or check if there are any elements left. Not so with iterators. To reduce the pain I'll create a simple wrapper class for the iterator.</p>\r\n<div class=\"CodeRay\">\n  <div class=\"code\"><pre>[code]\nclass Wrapper(object):\n      &quot;&quot;&quot;A wrapper for iterable objects. Allows peeking and testing for emptiness.\n      &gt;&gt;&gt; g =Wrapper(range(10))\n      &gt;&gt;&gt; g.has_items\n      True\n      &gt;&gt;&gt; tuple(g)\n      (0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n      &gt;&gt;&gt; g.has_items\n      False\n      &gt;&gt;&gt; e =Wrapper([])\n      &gt;&gt;&gt; e.has_items\n      False\n     &quot;&quot;&quot;\n      def __init__(self, it):\n          self.it = iter(it)\n          self.has_items = True\n          self._setvalue()\n      def _setvalue(self):\n          try:\n              self.value = self.it.next()\n          except StopIteration:\n              self.has_items = False       # To simplify the for-loop\n      def __nonzero__(self):\n          return self.has_items\n      def peek(self):\n          return self.value\n      def __iter__(self):\n          return self\n      def next(self):\n          if not self.has_items:\n              raise StopIteration\n          old_val = self.value\n          self._setvalue()\n          return old_val \n[/code]</pre></div>\n</div>\n\r\n<p>Slightly verbose but does the trick. I originally misspelled <code>__nonzero__</code>, which created an interesting bug. The <code>StopIteration</code> exception was not caught and the entire iterator stopped cold after either of the input streams was finished. Remember count those underscores...</p>\r\n<p>Note that there are several ways to construct a wrapper that supports some of the basic operations needed for this task. I feel that this is the cleanest approach. (Please prove me wrong!)</p>\r\n<div class=\"CodeRay\">\n  <div class=\"code\"><pre>[code]\ndef merged(i1, i2):\n     &quot;&quot;&quot;merge(sorted iterable1, sorted iterable2) -&gt; new sorted iterable\n      &gt;&gt;&gt; list(merged((1, 5, 9), (2, 4, 10))))\n     [1, 2, 4, 5, 9, 10]\n      &gt;&gt;&gt; &quot;&quot;.join(merged('abbg', 'gnoux'))\n     'abbggnoux'\n      &quot;&quot;&quot;\n     i1 = Wrapper(i1)\n     i2 = Wrapper(i2)\n     while i1 and i2:\n         if i1.peek() &lt; i2.peek():\n             yield i1.next()\n        else:\n            yield i2.next()\n    # At least on of these loops is a NOP\n    for x in i1:\n        yield x\n    for x in i2:\n        yield x\n[/code]</pre></div>\n</div>\n\r\n<p>It is possible to extend <code>merged</code> to merge several iterators at once. Left as an exercise.</p>\r\n<p>For finite <em>unsorted</em> iterators you can use a combination of <code>itertools.chain</code> and <code>sorted</code>.</p>\r\n<p>\u00a0</p>", "locations": [], "user": {"body": "I am much more prolific in Twitter. See http://twitter.com/arsatiki\r\n", "profile_pic": "http://files.posterous.com/user_profile_pics/30986/che_baarissa_ilman_paitaa.png", "display_name": "Antti Rasinen", "firstname": "Antti", "lastname": "Rasinen", "profile_image_35": "http://files.posterous.com/user_profile_pics/30986/che_baarissa_ilman_paitaa_thumb.png", "last_activity": "2012/02/23 08:30:10 -0800", "nickname": "Antti", "id": 29785, "profile_url": "http://posterous.com/users/KPdfsrBQmB"}, "date": "2007-08-19 23:02:00+03:00", "replies_count": 0, "body_excerpt": "Hello! I am currently at page 77. The discussion is more theoretical (orders of growth, recurrences &c.) and thus there is less stuff to re-implement. Of course, the tools given in the initial pages are among the most important ones in the book. J...", "slug": "merging-iterators", "is_private": false, "likes_count": 0, "privatestring": "imytggmDsC", "number_of_comments": 0, "comments_count": 0, "current_member": "", "author_display_name": "Antti Rasinen", "post_image_115": null, "is_owned_by_current_user": null}